; 286 страница.

; В защищенном режиме программа не может выйти за пределы
; Объявленых ею сегментов, а также не может выполнить
; Действия, запрещенные атрибутами сегмента.

; Подключаем данную директиву, чтобы работать с 
; Расширенным набором команд. (Р-Ф).
.586P ; Разрешение трансляции всех комнд Pentium.

; Структура для описания дескрипторов сегментов.
; В з-р для каждого сегмента программы долже быть
; Определен дескриптор - 8-байтовое поле, в котором
; в определенном формате записываются базовый адрес сегмента, 
; его длина и некоторые другие характеристики. 
; В р-р сегменты определяются их базовыми адресами. (Р-Ф).
descr struct	; Начало объялвения структуры. (Описание структуры != выделение памяти).
	lim 	DW 0 ; Номер последнего байта сегмента (Тут 16 бит).
    ; База сегмента - определяет начальный линейный адрес сегмента в адр. пространтве.
    ; Лин. адр. - выражен не в виде (сегмент:смещение), а просто номером байта
    ; В адресном пространстве (В нашем случае лин. адр. тоже самое что и физич. 
    ; (но это в общем случае не так) если включена страничная адр. то лин. адр.
    ; может не совпадать с физическим, если выключена, то совпадают).
    ; Сегмент в з-р может располагаться в любом месте адр. пространства 4Гбайт.
    ; (base_1) 16 + (base_m) 8 + (base_h) 8 = 32    
	base_1 	DW 0 ; База сегмента 
	base_m 	DB 0 ; База сегмента 
	attr_1 	DB 0
	attr_2 	DB 0 ; Тут находятся старшие 4 бита номера последнего байта сегмента 
    ; (в сумме получается (lim==) 16 + 4 (0..3 бит attr_2) = 20 
    ; Получается, что размер сегмента ограничен 1Мбайт = 2^20 байт)
    ; Старший бит attr_2 указывает в каких единицах задается граница (бит дробности)
    ; Если == 0, то граница указывается в байтах
    ; Если == 1, то в блоках по 4Кбайт (Т.е. тогда сегмент будет ограничен 4Гбайт (2^20 *2^10 (==Кбайт) = 2^30 байт == 1Гбайт))
	base_h 	DB 0
descr ends
 
; Сегмент данных
data segment use16 ; use16 - это тип. в данном сегменте будут использоваться 16-битовые адреса.
    ; Выделяем память под соответсвующие структуры (под дескрипторы).
    ; Т.е. выше мы просто описали стректуру, а тут выделяем 
    ; Память, задавая явно параметры.
    ; Мы описываем эти дескрипторы потому что в з-р мы можем обращаться к сегментами
    ; Только используя их (дескрипторы). 
	; Таблица глобальных дескрипторов GDT.
	gdt_null descr 		<0, 0, 0, 0, 0, 0>
	gdt_data descr 		<data_size-1, 0, 0, 92h, 0, 0>
	gdt_code descr 		<code_size-1, 0, 0, 98h, 0, 0>  ; 98h - задаем attr_1 (сегмент команд)
    ; этот код (98h) говорит о том, что исполняемый сегмент, к которому запрещено обращение с целью записи и чтения.
	gdt_stack descr 	<255, 0, 0, 92h, 0, 0>          ; 92h - задаем attr_1 (сегмент данных (или стека) с кодом 
    ; этот код (92h) говорит о том, что это сегмент данных с разрешением записи и чтения) 
	; gdt_screen - это дескриптор видеопамяти (Чтобы выводить символы). 
    ; 255 байт - соответствует размеру стека. 
    gdt_screen descr 	<3999, 8000h, 0Bh, 92h, 0, 0>   ; attr_2 - там указан тип дробности в нашем случае он везде равен 0 (т.е. граница указывается в байтах)
	; Размер видеостраницы составляет 4000 байт - поэтому граница 3999.
    ; B8000h - базовый физический адрес страницы ( 8000h и 0Bh). 
    ; (Видео память размещена в первом Мегабайте адр. пр-ва поэтому base_m = 0).
    gdt_size=$-gdt_null ; Размер GDT.
	; Различные данные программы.
	pdescr  DF 0 ; DF - выделить поле для псевдодескриптора (6-байт).
	sym     DB 1
	attr    DB 1Eh
	msg     DB 27, '[31;42m  Вернулись в реальный режим! ' ,27, '[0m$'
	data_size=$-gdt_null
data ends
 
; Сегмент команд. 
text segment use16 ; use16 - т.к. мы составляем 16  - разрядное предложение 
; (Но при этом можно использовать 32 разрядные регистры).
    assume CS:text,DS:data
 
main proc
    XOR EAX, EAX ; Обнуляем регистр EAX.
    ; Инициализируем регистр DS для работы в р-р.
    MOV AX, data
    MOV DS, AX

    ; Линейные (32-битовые) адреса определяются путем умножения значений
    ; сегментных адресов на 16.
    shl EAX, 4 ; В EAX теперь лежит линейный 32-битовый адрес.
    MOV EBP, EAX ; Т.к. этот адрес будет дальше использоваться он созраняется в EBP.
    MOV BX, offset gdt_data ; В BX загружается смещение дескрипттора сегмента данных.
    MOV [BX].base_1, AX ; В дескриптор заноситтся младшая половина лин. адреса (данных вроде).
    SHR EAX, 16 ; сдвигаем  вправо (т.к. к старшей половине мы не можем обратиться в 16-разр.-р.)
    MOV [BX].base_m, AL ; В base_m заносим заносим содержимое AL.
    XOR EAX, EAX ; Обнуляем регистр EAX.

    ; Аналогично вычисляются и заносятся в соответствующие поля дескрипторов 
    ; (gdt_code и gdt_stack) 32-битовые линейные адреса сегментов команд и стека.
    MOV AX, CS
    SHL EAX, 4
    MOV BX, offset gdt_code
    MOV [BX].base_1, AX
    SHR EAX, 16
    MOV [BX].base_m, AL

    XOR EAX, EAX
    MOV AX, SS
    SHL EAX, 4
    MOV BX, offset gdt_stack
    MOV [BX].base_1, AX
    SHR EAX, 16
    MOV [BX].base_m, AL
 
    ; LGDT (Load GDT) - загружает в регистр процессора GDTR (GDT Register)
    ; информацию о таблице глобольных дескрипторов 
    ; (лин. базовый адрес иаблицы и ее границу). (Размещается в 6-байтах.)
    MOV DWORD ptr pdescr+2, EBP      ; Заносится лин. адрес GDT.
    MOV WORD  ptr pdescr, gdt_size-1 ; Заносится поле границы.
    LGDT pdescr ; pdescr - псевдодескриптор.
 
    ; Подготавливаемся к возврату из з-р в р-р.
    ; Возрат в р-р можно осуществить сбросом процессора.
    ; Действия процессора после сброса определяются байтом
    ; Состояния отключения, который располагается по адресу Fh.
    ; В частности если там щаписано 0Ah, то после сброса
    ; Управление передастся по адресу, который извлекается из двухсловной 
    ; Ячейки 40h:67h, расположенной в области данных BIOS.
    ; Т.е. для подготовки возрата в р-р мы должны в 
    ; Ячейку 40h:67h записать адрес возврата (return).
    ; А в байт Fh - занести код Ah.
    MOV AX, 40h
    MOV ES, AX
    MOV WORD ptr ES:[67h], offset return
    MOV ES:[69h], CS
    ; В порт 70h засылается код 0Fh, который 
    ; Выбирает для записи байт Fh,
    MOV AL, 0Fh
    OUT 70h, AL
    ; А затем в порт 71h посылается код 0Ah
    ; определяющий режим востановления.
	MOV AL, 0Ah
    OUT 71h, AL
    ; Запрещаем аппаратные прерывания.
    ; Т.к. в з-р процессор выполняет процедуру прерывания
    ; Не так как в р-р. (На 293 стр внизу написано как он выполняет)
    ; (Коротко: при возникновении прерывания адресс обработки прерывания
    ; берется из таблицы дескрипторов прерывания, а у нас такой таблицы нет. 
    ; (в р-р процессор обращается к таблице векторов прерываний в первом килобайте памяти))
    CLI ; Запрет аппаратных прерываний.
 
    ; Переходим в з-р.  
    ; Устанавливаем бит PM (в тетрадке написано PE) 
    ; в управляющем регистре процессора CR0
    ; Обращение к регистром управления CR0
    ; Осуществляется исключительно командой MOV (причем второй операнд должен быть рег. общ. назначения).
    ; Поэтому мы сначала записывае CR0 в рег. общ. назначания EAX
    ; Поднимаем флаг PM, а потом перезаписываем содержимое регистра управления CR0.
    MOV EAX, CR0
    OR EAX, 1 ; Поднимаем бит, которые переведет процессор в з-р.
    MOV CR0, EAX ; Вот тут переводим в з-р процессор.
 
    ; Теперь процессор работает в з-р.
    ; Для кажого из сегментных регистров имеется теневой регистр дескриптора,
    ; который имеет формат дескриптора. Тен. рег. не доступны программисту.
    ; Они автоматически загружаются процессором из таблицы дескрипторов
    ; Каждый раз, когда процессор инициализирует соответствующий сегментный регистр.
    ; В з-р прогаммист имеет дело с селекторами, т.е. номерами дескрипторов,
    ; А процессор с самими дескрипторами, хранящимися в теневых регистрах.
    ; (Лин адрес сегмента, который хранится в тен. рег. определяет область памяти,
    ; К которой обращается процессор при выполнении конкретной программы).
    
    ; Загружаем в CS:IP селектор:смещение точки continue. 
    ; Мы используем jmp (дальнего перехода), чтобы изменить содержимое CS:IP
    ; Т.к. нам недоступно прямое образение к регистру CS 
    ; (мы не можем загрузить туда селектор).
    DB 0EAh             ; Код команды far jmp.
    DW offset continue  ; Смещение.
    ; Указатель на описание сегмента называется селектор. 
    ; Другими словами, селектор - это номер дескриптора из таблицы дескрипторов.
    DW 16               ; Селектор сегмента команд. (Записываем селектор, т.к. в з-р)
continue:
    ; Загружаем селекторы в сегментные регистры DS, SS, и ES 
    
    ; Делаем адресуемыми данные. 
    ; Загружаем в DS селектор сегмента данных.
    MOV AX, 8
    MOV DS, AX
 
    ; Делаем адресуемым стек. 
    ; Загружаем в SS селектор сегмента стека.
    MOV AX, 24
    MOV SS, AX
 
    ; Загружаем в SS селектор сегмента видеобуфера.
    MOV AX, 32
    MOV ES, AX
 
    ; Вывод на экран текстовой строки.
    MOV DI, 1920 ; Начальная позиция экрана.
    MOV CX, 80   ; Число выводимых символов. 
    MOV AX, WORD ptr sym ; Символ (sym) + атрибут (attr)
scrn: 
    STOSW       ; Содержимое AX вывести на экран.
    INC AL      ; Инкременд кода символа.
    LOOP scrn   ; Цикл вывода.

    ; Возвращаемся в реальный режим. 
    ; (Чтобы не нарушить работоспособность DOS)
    ;  (после чего сможем завершить программу обычным образом)
    ; Чтобы вернутья в р-р: 
    ; Сброс процессора засылкой команды FEh в порт 64h.
    ; Стра 295 подробнее
    ; (Коротко: эта команда возбуждает сигнал на клаве, который в 
    ; конечном счете приводит к появлению сигнала сброса на выводе RESET микропроцессора)
    MOV AL, 0FEh
    ; После сброса процессор работает в р-р.
    ; Причем упарвление передается одной из программ BIOS, которая анализирует
    ; Содержимое байта состояния отключения (0Fh) микросхемы
    ; И т.е. мы туда ранее записали 0Ah, то То осеществляется передача управления
    ; По адресу 40h:67h (ранее мы положили в эту ячейку адрес return)
    OUT 64h, AL
    ; (Можно было вместо HLT сделать бесконечный цикл).
    ;  Если hlt опустить, то процессор до своего останова успеет выполнить несколько 
    ;  След. команд, после чего перейдет на метку return.
    HLT ; hlt (halt - останов) - организовывает ожидание сброса процессора.  
return: ; (Вот сюда мы вернемся когда выйдем из з-р, т.е. вернемся в р-р)
    ; Т.к. передача управления на метку return осуществляется
    ; Программами BIOS, то эти программы использовали регистры процессора.
    ; Поэтому нам нужна заново инициализировать их (В частности SS, DS и SP)
    ; Восстанавливаем вычислительную среду реального времени. 
    MOV AX, data 
    MOV DS, AX
    MOV AX, stk
    MOV SS, AX
    MOV SP, 256 ; Указатель стека указывает на вершину стека.
    STI ; Резрешаем (аппаратные) прерывания
 
    ; Теперь программа может продолжить работать в р-р.
    ; Для проверки работоспособности выводится текст 
    MOV AH, 09h
    MOV DX, offset msg
    INT 21h
    ; Заверение программы.
    MOV AX, 4C00h
    INT 21h
main endp

code_size = $-main
text ends
 
; Стек сегмента.
stk segment stack use16
    DB 256 dup('^')
stk ends

end main