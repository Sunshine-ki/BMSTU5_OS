; 286 страница.

; В защищенном режиме программа не может выйти за пределы
; Объявленых ею сегментов, а также не может выполнить
; Действия, запрещенные атрибутами сегмента.

; Подключаем данную директиву, чтобы работать с 
; Расширенным набором команд. (Р-Ф).
.586P ; Разрешение трансляции всех комнд Pentium.

; Структура для описания дескрипторов сегментов.
; В з-р для каждого сегмента программы долже быть
; Определен дескриптор - 8-байтовое поле, в котором
; в определенном формате записываются базовый адрес сегмента, 
; его длина и некоторые другие характеристики. 
; В р-р сегменты определяются их базовыми адресами. (Р-Ф).
descr struct	; Начало объялвения структуры. (Описание структуры != выделение памяти).
	lim 	DW 0 ; Номер последнего байта сегмента (Тут 16 бит).
    ; База сегмента - определяет начальный линейный адрес сегмента в адр. пространтве.
    ; Лин. адр. - выражен не в виде (сегмент:смещение), а просто номером байта
    ; В адресном пространстве (В нашем случае лин. адр. тоже самое что и физич. 
    ; (но это в общем случае не так) если включена страничная адр. то лин. адр.
    ; может не совпадать с физическим, если выключена, то совпадают).
    ; Сегмент в з-р может располагаться в любом месте адр. пространства 4Гбайт.
    ; (base_1) 16 + (base_m) 8 + (base_h) 8 = 32    
	base_1 	DW 0 ; База сегмента 
	base_m 	DB 0 ; База сегмента 
	attr_1 	DB 0
	attr_2 	DB 0 ; Тут находятся старшие 4 бита номера последнего байта сегмента 
    ; (в сумме получается (lim==) 16 + 4 (0..3 бит attr_2) = 20 
    ; Получается, что размер сегмента ограничен 1Мбайт = 2^20 байт)
    ; Старший бит attr_2 указывает в каких единицах задается граница (бит дробности)
    ; Если == 0, то граница указывается в байтах
    ; Если == 1, то в блоках по 4Кбайт (Т.е. тогда сегмент будет ограничен 4Гбайт (2^20 *2^10 (==Кбайт) = 2^30 байт == 1Гбайт))
	base_h 	DB 0
descr ends
 
; Сегмент данных
data segment use16 ; use16 - это тип. в данном сегменте будут использоваться 16-битовые адреса.
    ; Выделяем память под соответсвующие структуры (под дескрипторы).
    ; Т.е. выше мы просто описали стректуру, а тут выделяем 
    ; Память, задавая явно параметры.
    ; Мы описываем эти дескрипторы потому что в з-р мы можем обращаться к сегментами
    ; Только используя их (дескрипторы). 
	; Таблица глобальных дескрипторов GDT.
	gdt_null descr 		<0, 0, 0, 0, 0, 0>
	gdt_data descr 		<data_size-1, 0, 0, 92h, 0, 0>
    ; 92h 1001 0010 - 
    ; 98h 1001 1000 -
	gdt_code descr 		<code_size-1, 0, 0, 98h, 0, 0>  ; 98h - задаем attr_1 (сегмент команд)
    ; этот код (98h) говорит о том, что исполняемый сегмент, к которому запрещено обращение с целью записи и чтения.
	gdt_stack descr 	<255, 0, 0, 92h, 0, 0>          ; 92h - задаем attr_1 (сегмент данных (или стека) с кодом 
    ; этот код (92h) говорит о том, что это сегмент данных с разрешением записи и чтения) 
	; gdt_screen - это дескриптор видеопамяти (Чтобы выводить символы). 
    ; 255 байт - соответствует размеру стека. 
    gdt_screen descr 	<3999, 8000h, 0Bh, 92h, 0, 0>   ; attr_2 - там указан тип дробности в нашем случае он везде равен 0 (т.е. граница указывается в байтах)
	; Размер видеостраницы составляет 4000 байт - поэтому граница 3999.
    ; B8000h - базовый физический адрес страницы ( 8000h и 0Bh). 
    ; (Видео память размещена в первом Мегабайте адр. пр-ва поэтому base_m = 0).
    gdt_size=$-gdt_null ; Размер GDT.
	; Различные данные программы.

	pdescr  DF 0 ; DF - выделить поле для псевдодескриптора (6-байт).
	sym             DB 1
	attr            DB 1Eh
	msg             DB  'Real mode ', 0dh,0ah, '$'      ; 0dh,0ah - перенос строки
	msg_protected   DB  'Protected mode', 0dh,0ah ;, '$'  ; '$' - конец строки
    len_msg_protected=$-msg_protected

	data_size=$-gdt_null
data ends
 
; Сегмент команд. 
text segment use16 ; use16 - т.к. мы составляем 16  - разрядное предложение (16-ти разрядные опреанды)
; (Но при этом можно использовать 32 разрядные регистры).
    assume CS:text,DS:data
 
main proc

    MOV AX, data 
    MOV DS, AX

    MOV AH, 09h
    MOV DX, offset msg
    INT 21h

    XOR EAX, EAX ; Обнуляем регистр EAX.
    ; Инициализируем регистр DS для работы в р-р.
    MOV AX, data
    MOV DS, AX

    ; Линейные (32-битовые) адреса определяются путем умножения значений
    ; сегментных адресов на 16.
    shl EAX, 4 ; В EAX теперь лежит линейный 32-битовый адрес.
    MOV EBP, EAX ; Т.к. этот адрес будет дальше использоваться он созраняется в EBP.
    MOV BX, offset gdt_data ; В BX загружается смещение дескрипттора сегмента данных.
    MOV [BX].base_1, AX ; В дескриптор заноситтся младшая половина лин. адреса (данных вроде).
    SHR EAX, 16 ; сдвигаем  вправо (т.к. к старшей половине мы не можем обратиться в 16-разр.-р.)
    MOV [BX].base_m, AL ; В base_m заносим заносим содержимое AL.
    XOR EAX, EAX ; Обнуляем регистр EAX.

    ; Аналогично вычисляются и заносятся в соответствующие поля дескрипторов 
    ; (gdt_code и gdt_stack) 32-битовые линейные адреса сегментов команд и стека.
    MOV AX, CS
    SHL EAX, 4
    MOV BX, offset gdt_code
    MOV [BX].base_1, AX
    SHR EAX, 16
    MOV [BX].base_m, AL

    XOR EAX, EAX
    MOV AX, SS
    SHL EAX, 4
    MOV BX, offset gdt_stack
    MOV [BX].base_1, AX
    SHR EAX, 16
    MOV [BX].base_m, AL
 
    ; LGDT (Load GDT) - загружает в регистр процессора GDTR (GDT Register)
    ; информацию о таблице глобольных дескрипторов 
    ; (лин. базовый адрес (4 байта) таблицы и ее границу (2 байта)). (Размещается в 6-байтах.)
    ; Т.е. там лежит линейный адрес начала таблицы глобальных дескрипторов.
    MOV DWORD ptr pdescr+2, EBP      ; Заносится лин. адрес GDT.
    MOV WORD  ptr pdescr, gdt_size-1 ; Заносится поле границы.
    LGDT pdescr ; pdescr - псевдодескриптор.
 
 
    CLI ; Запрет аппаратных прерываний.
 
    ; Переходим в з-р.  
    ; Устанавливаем бит PM (в тетрадке написано PE) 
    ; в управляющем регистре процессора CR0
    ; Обращение к регистром управления CR0
    ; Осуществляется исключительно командой MOV (причем второй операнд должен быть рег. общ. назначения).
    ; Поэтому мы сначала записывае CR0 в рег. общ. назначания EAX
    ; Поднимаем флаг PM, а потом перезаписываем содержимое регистра управления CR0.
    MOV EAX, CR0
    OR EAX, 1 ; Поднимаем бит, которые переведет процессор в з-р.
    MOV CR0, EAX ; Вот тут переводим в з-р процессор.
 
    ; Теперь процессор работает в з-р.
    ; Для кажого из сегментных регистров имеется теневой регистр дескриптора,
    ; который имеет формат дескриптора. Тен. рег. не доступны программисту.
    ; Они автоматически загружаются процессором из таблицы дескрипторов
    ; Каждый раз, когда процессор инициализирует соответствующий сегментный регистр.
    ; В з-р прогаммист имеет дело с селекторами, т.е. номерами дескрипторов,
    ; А процессор с самими дескрипторами, хранящимися в теневых регистрах.
    ; (Лин адрес сегмента, который хранится в тен. рег. определяет область памяти,
    ; К которой обращается процессор при выполнении конкретной программы).
    
    ; Загружаем в CS:IP селектор:смещение точки continue. 
    ; Мы используем jmp (дальнего перехода), чтобы изменить содержимое CS:IP
    ; Т.к. нам недоступно прямое образение к регистру CS 
    ; (мы не можем загрузить туда селектор).
    DB 0EAh             ; Код команды far jmp.
    DW offset continue  ; Смещение.
    ; Указатель на описание сегмента называется селектор. 
    ; Другими словами, селектор - это номер дескриптора из таблицы дескрипторов.
    DW 16               ; Селектор сегмента команд. (Записываем селектор, т.к. в з-р)
continue:
    ; Загружаем селекторы в сегментные регистры DS, SS, и ES 
    
    ; Делаем адресуемыми данные. 
    ; Загружаем в DS селектор сегмента данных.
    MOV AX, 8
    MOV DS, AX
 
    ; Делаем адресуемым стек. 
    ; Загружаем в SS селектор сегмента стека.
    MOV AX, 24
    MOV SS, AX
 
    ; Загружаем в SS селектор сегмента видеобуфера.
    MOV AX, 32
    MOV ES, AX
 
    ; Вывод на экран текстовой строки.
    MOV DI, 1920 ; Начальная позиция экрана.
    MOV CX, len_msg_protected   ; Число выводимых символов. 
    MOV AX, WORD ptr sym ; Символ (sym) + атрибут (attr)
scrn: 
    STOSW       ; Содержимое AX вывести на экран.
    INC AL      ; Инкременд кода символа.
    LOOP scrn   ; Цикл вывода.

    ; Возвращаемся в реальный режим. 
	; При работе в р-р поля теневых регистров должны быть
	; заполнены определенным способом. Так для сегментов
	; Данных, стека и коода должны быть установлены границы FFFFh 
	; (любое другое значение не устраивает р-р)
	; (Мои слова: так как в р-р предел (лимит) определен
	;  Максимально возможным значанием, в нашем случае FFFFh)
	; (Бит дробности должен быть установлен в 0. Доступ для записи 
	; разрешен - это для стека и данных). 

	; Если мы просто перейдем в р-р сбросом бита в регистре CR0
	; То в тен. рег. останутся дескрипторы з-р и при первом же обращении
	; К любому сегменту программы возникнет иключение общей защиты, 
	; Т.к. ни один из наших сегментов не имеет границы, равной FFFFh. 
	; (Произойдет сброс процессора и перезагрузка комп.)
	MOV gdt_data.lim, 0FFFFh ; Граница сегмента данных.
	MOV gdt_code.lim, 0FFFFh ; Граница сегмента команд.
	MOV gdt_stack.lim, 0FFFFh ; Граница сегмента стека.
	MOV gdt_screen.lim, 0FFFFh ; Граница доп. сегмента (Видеобуфера).

	; Далее идет перезапись теневых регистров 
	; (Благодаря загрузки селекторов в сегментные регистры). 
	; (Мои слова: Далее, чтобы теневые регистры
	; Приняли свои значения, мы должны в 
	; Сегментные регистры записать значения
	; Для этого мы как раз и выполняем запись в сегментные регистры
	; После этого процессор сам восстоновит теневые регистры 
	; (мы не можем сами обращаться к теневым регистрам, поэтому делаем так)). 
	PUSH DS ; Загружаем теневой регистр
	POP DS  ; Сегмента данных. 

	PUSH SS ; Загружаем теневой регистр
	POP SS 	; Сегмента стека.

	PUSH ES ; Загружаем теневой регистр
	POP ES  ; Дополнительного сегмента данных (видеобуфера).

	; (Регистр CS непосредственно загрузить нельзя,
	; Поэтому выполняем искусственно сформированный вызов дальнего перехода).
	; Выполняет дальний переход, чтобы заново загрузить селектор
	; В регистр CS и модифицировать его тен. рег.
	DB 0EAh 		; Команда дальнего перехода
	DW offset go 	; Загрузим теневой регистр
	DW 16 			; Сегмента команд.

	; Переключим режим процессора.
go:  
	MOV EAX, CR0
	AND EAX, 0FFFFFFFEh ; Сбрасываем бит защищенного режима.
	MOV CR0, EAX 		; Запишем в CRO значени, в котором сброшен бит з-р.
	
	; ПЕРЕШЛИ В р-р.
	; Снова выполняем дальний переход, 
	; Чтобы загрузить в регистр CS вместо хранящегося там селектора
	; Обычный сегментный адрес регистра команд.
	DB 0EAh 			; Код команды far jmp
	DW offset return 	; Смещение 
	DW text 			; Сегмент.

	; ТЕПЕРЬ ПРОЦЕССОР СНОВА РАБОТАЕТ В Р-Р.
return: ; (Вот сюда мы вернемся когда выйдем из з-р, т.е. вернемся в р-р)
    ; Т.к. передача управления на метку return осуществляется
    ; Программами BIOS, то эти программы использовали регистры процессора.
    ; Поэтому нам нужна заново инициализировать их (В частности SS, DS и SP)
    ; Восстанавливаем вычислительную среду реального времени. 

	; После перехода в р-р необходимо загрузить
	; В используемые далее сегментные регистры 
	; соответствубщие сегментные адреса.
    MOV AX, data 
    MOV DS, AX
    MOV AX, stk
    MOV SS, AX
    MOV SP, 256 ; Указатель стека указывает на вершину стека.
    STI ; Резрешаем (аппаратные) прерывания
 
    ; Теперь программа может продолжить работать в р-р.
    ; Для проверки работоспособности выводится текст 
    MOV AH, 09h
    MOV DX, offset msg
    INT 21h
    ; Заверение программы.
    MOV AX, 4C00h
    INT 21h
main endp

code_size = $-main
text ends
 
; Стек сегмента.
stk segment stack use16
    DB 256 dup('^')
stk ends

end main